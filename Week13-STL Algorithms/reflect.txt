/*
* Name - Avni Goyal
* Seneca Email - agoyal31@myseneca.ca
* Seneca Student ID - 166795211
* Date of completion - 2023/08/19
*/
//I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.

1. To begin with, the display function utilizes an STL function, for_each, to perform an operation on the entire CrimeCollection vector. This function resembles a for loop and is responsible for invoking the << function to display each vector within the collection. Moving forward, another STL function employed is std::sort, which organizes the crimeCollection vector. It takes three arguments: the vector's beginning, end, and a lambda function that determines the sorting criteria based on attributes like Province, Crime, and Cases. The lambda expression takes two Crime arguments, a and b, supplied by the sort function, returning true or false to determine their order. Moving further, transform, modifies the contents of the array. It replaces occurrences of [None] with an empty string. With four arguments, this function takes the vector's start and end positions, the insertion point for modified elements, and a lambda expression to carry out the change. For instance, transforming [None] to "" and returning the object for reinsertion. Furthermore,  any_of function, used to assess if any object meets a specified condition. In our case, it confirms if a crime name matches the target name, returning true if any such match is found within the data collection. Lastly, copy_if is employed to transfer or copy data from one container to another, subject to a condition. It takes the source vector's start and end positions, the destination list, and a lambda expression that returns true for data fulfilling the condition. In this scenario, only data records with a province name matching the target province are included.
2. STL algorithms offer numerous advantages over manual loops. They streamline tasks by handling much of the work. For example, in the transform function, specifying start and end points and the desired alteration is sufficient. They are versatile, functioning with various data structures. Furthermore, these algorithms are designed by experts for optimal memory consumption and execution time. Their concise nature, efficiency, and ability to work across different data structures contribute to their effectiveness.
3. Lastly by using Regular Expressions, this issue can be handles. If we want more advanced input validation, regular expressions can be powerful tools. Regular expressions can be used to match specific patterns, making sure the input adheres to a certain format. Regular expressions offer more sophisticated pattern matching and can be especially useful when dealing with complex input validation requirements.
That was all for this workshop. Thanks
